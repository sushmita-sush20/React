Assignment06
------------

1) What is a Microservice?
A: The idea is to split your application into a set of smaller, interconnected services instead of building a single monolithic application. Each service handles a specific job, like handling user accounts or managing payments. Inside each service, there's a mini-world of its own, with its own set of rules (business logic) and tools (adapters). Some services talk to eachother in different ways, like using REST or messaging. Others might even have their own website!

   Simpler Development: Microservices break down complex applications into smaller, easier-to-handle services. This makes development faster and maintenance easier.
   -------------------

   Independent Teams: Each service can be developed independently by a team maintenance easier.
   -----------------

   Flexibility in Technology: Developers have the freedom to choose the best  technologies for each service, without being tied to choices made at the project's start.
   -------------------------

   Continuous Deployment: Microservices allow for independent deployment, enabling continuous deployment for complex applications.
   ---------------------

   Scalability: Each service can be scaled independently, ensuring efficient resource usage.
   -----------

   Separation of Concerns: With each task having its own project, the architecture stays organized and manageable.
   ----------------------

   Single Responsibility: Every service has its own job, following the principle of single responsibility. This ensures focused and efficient development.
   ---------------------

2) What is Monolith architecture?
A: In the past, we used to build large projects where everything was bundled together. Imagine building an entire application where all the code—APIs, user interface, database connections, authentication, even notification services
   —resides in one massive project with single code base.

Size and Complexity Limitation: Monolithic applications become too large and complex to understand.
------------------------------

Slow Startup: The application's size can slow down startup time. Full Deployment Required: Every update requires redeploying the entire application.
-------------

Limited Change Understanding: It's hard to grasp the full impact of changes, leading to extensive manual testing.
----------------------------

Difficult Continuous Deployment: Implementing continuous deployment is challenging.
-------------------------------

Scaling Challenges: Different modules may have conflicting resource needs, making scaling difficulty.
------------------

Reliability Concerns: Bugs in any module can crash the whole application, affecting availability.
---------------------

Adoption of New Technologies: Making changes in frameworks or languages is expensive and time-consuming since it affects the entire application.
-----------------------------

3) What is the difference between Monolith and Microservice?
A: Monolith:
   --------
   - One big application with all features packed together.
   - All code is in a single project.
   - Hard to change one part without affecting others.
   - If one part fails, the whole app can crash.
   - Easier to start building, but becomes harder to manage as it grows.
   Ex: A single app handles login, menus, orders, and payments all together.

   Microservice:
   -------------
   - Many small, separate services, each doing one job.
   - Each service has its own project/code.
   - Easy to update one service without touching the rest.
   - If one service fails, others can still work.
   - More complex to set up, but easier to maintain in the long run.
   Ex: Separate services for login, menus, orders, and payments.

4) Why do we need a useEffect Hook?
A: We need useEffect in React to run code when something happens in our component — like after it first shows up on the screen, or when certain data changes.

In simple words:

   -It lets us handle side effects — things that are outside the normal UI rendering, like:
   ->Fetching data from an API
   ->Updating the browser title
   ->Setting up timers or event listeners

   - Without useEffect, React components would only handle displaying stuff, and we’d have no clean way to run this “extra” work at the right time.

5) What is Optional Chaining?
A: Optional Chaining (?.) is a JavaScript feature that lets you safely access deeply nested object properties without getting an error if something in the chain is null or undefined.

   Simple meaning:
   --------------
   It checks each step in the chain before going forward. If something is missing, it stops and returns undefined instead of crashing.

   Ex: const user = {
          profile: {
            name: "Sushmita"
          }
        };

        console.log(user.profile?.name); // "Sushmita"
        console.log(user.address?.street); // undefined (no error)

    -Without optional chaining, user.address.street would throw an error because address doesn’t exist.

6) What is Shimmer UI?
A: Shimmer UI is a loading placeholder that shows a gray, animated skeleton shape where your content will appear while the real data is still loading.

   Simple meaning:
   ---------------
   It’s like a fake preview of your page so the user knows something is coming, instead of staring at a blank screen.

   Why it’s used:
   --------------
   - Makes the app look faster and smoother
   - Improves user experience
   - Reduces the feeling of waiting

7) What is the difference between JS expression and JS statement
A: JavaScript Expression:
   ----------------------
   Definition: A piece of code that produces a value.
   -----------
   It can be stored in a variable or used inside another expression.

   Ex: 5 + 3         // produces 8
       "Hello" + " World" // produces "Hello World"
       x > 10        // produces true or false

   - Expressions return something.

   JavaScript Statement:
   ---------------------
   Definition: A complete instruction that performs an action.
   ----------
   It may contain expressions, but it doesn’t always return a value.

   Ex: let sum = 5 + 3; // declaration statement
       if (sum > 5) {   // if statement
         console.log("Bigger than 5");
       }
   - Statements do something.

8) What is Conditional Rendering, explain with a code example
A: Conditional Rendering in React means showing different UI elements depending on certain conditions — just like using if...else in normal JavaScript, but inside JSX.

   Ex: import React, { useState } from "react";

       function App() {
         const [isLoggedIn, setIsLoggedIn] = useState(false);

         return (
          <div>
             {isLoggedIn ? (
               <h1>Welcome back, user!</h1>
            ) : (
               <h1>Please log in</h1>
             )}

             <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
               {isLoggedIn ? "Logout" : "Login"}
            </button>
           </div>
         );
       }

       export default App;
 
   How it works:
   -------------
     - isLoggedIn is a state that stores whether the user is logged in.
     - Inside JSX, we use ? : (ternary operator) to decide which element to show.

     - Button toggles between Login and Logout.

   -> In short: Conditional rendering lets you dynamically change what appears on screen depending on data, state, or user actions.

9) What is CORS?
A: CORS (Cross-Origin Resource Sharing) is a security rule in web browsers that decides whether a website can request data from another website’s server.

   By default, browsers block requests to a different domain for security reasons.
   CORS lets the server say, “It’s okay, this site can access my data.”

10) What is async and await?
A:  async and await are JavaScript keywords that make working with promises easier and more readable.

    - async → Marks a function as asynchronous. It always returns a promise.
    - await → Pauses the code inside an async function until a promise is resolved, then gives you the result.
   
    Ex: async function getData() {
         let response = await fetch("https://api.example.com/data");
         let data = await response.json();
         console.log(data);
       }

       getData();
   
    - Here, await makes the code wait for fetch() and response.json() to finish before moving on, so you can write async code like normal step-by-step code.

11) What is the use of `const json = await data.json();` in getRestaurants()
A:  In getRestaurants(), the line
      
     const json = await data.json();
  
    is used to convert the raw HTTP response into usable JavaScript data.

    Here’s the breakdown:
    ---------------------
   (i) data → This is the raw HTTP response object you get from fetch().
       Ex: const data = await fetch("https://api.example.com/restaurants");

   (ii) .json() → This is a method on the Response object that reads the body and parses it into a JavaScript object (assuming the server sent JSON).
        - Without this, you can’t directly use the data — it’s still in raw text format.

   (iii) await → Since .json() returns a promise, await makes sure we wait for the parsing to finish before storing the result in json.

   So in short:
   ------------
     const json = await data.json(); → "Wait until the server response is converted from raw JSON text into a real JavaScript object, then store it in json."

   - If you skip this step, you’ll just have an unreadable HTTP response body instead of real data.    



